# Пояснительная записка

1. Система сборки выбрана _Cmake_. 
Главная cmake-цель - **mtfind**.
Были описаны юнит-тесты для всех граничных кейсов, которые пришли в голову. 
Включить/выключить сборку тестов можно с помощью опции `option(WITH_TESTS "Build test (over gtest)" ON)`.
Цель сборки для тестов - **tests**.

2. Первая попытка была реализована с использованием стандарных потоков.
Был получен неудовлетворительный результат по скорости.

3. Вторая попытка была реализована на кастомном потоке ввода, для которого был реализован 
свой потковый буфер (поскольку чтение производится только в одном направлении и возврат 
менее чем на длину маски, часть данных не нужно читать повторно). Скорость возросла незначительно.
Профилирование показало большое количество вызовов для позиционирования в файле.

4. Было решено отказаться от потоков и реализовать сперциальную работу с буфером. 
При реализации распараллеливания добавлены юнит-тесты на слияние результатов работы отдельных потоков.
Так же выявлен кейс для самопересекающихся масок, для чего было реализовано сохранение всех подходящих 
вхождений, а разрешение пересечений при слиянии результатов.

5. Замеры скорости показали приемлемый результат (на несколько порядков быстрее самого первого варианта).
Размер буфера влияет прямо пропорционально на скорость, но после достижения размера около 4kb практически 
не влияет. Скорее всего это связано с блочным чтением с ФС.   

6. Многопоточность влияет на скорость приблизительно линейно до достижения числа потоков равному числу ядер.
После этого скорость начинает медленно падать - вносит негативное влияние менеджмент потоков 
(переключение контекста и т.п.). Сейчас выполнение параллелится на число потоков не менее числа масок, 
покрывающих размер файла, но не более числа ядер на машине.  
Многопоточность начинает себя проявлять только с достаточно большими файлами (десятки килобайт). На мелких
файлах каждый поток успевает отработать быстрее, чем система породит очередной. 

7. Алгоритм линейный - сложность O(M*N), (где M - размер файла, N - размер маски). В программе используются 8кб буферы. 
Потребление памяти очень скромное, так как на куче хранится только список позиций. Больше места занимают стеки потоков.   

8. Что можно улучшить:
- определять, является ли маска самопересекающейся (начало маски является копией конца). 
 Для таких случаев можно не возвращаться к началу анализируемого фрагмента, а идти дальше. 
 Это позволит улучшить сложность для таких случаев до О(M+N).
 - порождать минимальное число потоков для маленьких файлов, или вовсе выполнять в одном потоке. 
 - ограничить стек рабочих потоков. 

9. На выполнение задания потребовалось около 10 часов: с экспериментами, написанием тестов, кода, пояснительной записки.  
